---
- name: Provisioning EDPM nodes
  hosts: localhost
  gather_facts: true

  tasks:
    - name: Download OCP inventory file (scalelab)
      uri:
        url: "https://wiki.scalelab.redhat.com/instack/{{ cloud }}_ocpinventory.json"
        return_content: true
      register: ocpinventory_scale
      when: lab == 'scalelab'

    - name: Download OCP inventory file (performancelab)
      uri:
        url: "https://wiki.rdu3.labs.perfscale.redhat.com/instack/{{ cloud }}_ocpinventory.json"
        return_content: true
      register: ocpinventory_alias
      when: lab == 'performancelab'

    - name: Set fact for OCP inventory
      set_fact:
        ocp_inventry: "{{ ocpinventory_scale if lab == 'scalelab' else ocpinventory_alias }}"

    - name: Parse nodes from OCP inventory
      set_fact:
        all_nodes: "{{ (ocp_inventry.content | from_json).nodes }}"

    - name: Set final compute count
      set_fact:
        final_compute_count: >-
          {% set nodes_length = ocp_inventry.json.nodes | length %}
          {% if compute_count == -1 %}
            {{ nodes_length | int }}
          {% else %}
            {% set temp = compute_count + 4 %}
            {% if temp > nodes_length %}
              {{ nodes_length | int }}
            {% else %}
              {{ temp | int }}
            {% endif %}
          {% endif %}

    - name: Show final compute count
      debug:
        msg: "Final compute count is {{ final_compute_count }}"

    - name: get the EDPM nodes
      set_fact:
        edpm_nodes: "{{ ocp_inventry.json.nodes[4:final_compute_count|int] | map(attribute='name') | list }}"

    - name: Set fact for USER and PASSWORD
      ansible.builtin.set_fact:
        user: "{{ all_nodes[0].pm_user }}"
        password: "{{ all_nodes[0].pm_password }}"

    - name: Generate Foreman configuration file
      template:
        src: "{{ ansible_user_dir}}/JetBrew/ansible/roles/foreman/templates/foreman_config.j2"
        dest: "/tmp/foreman_config_updated_{{ cloud }}.yml"

    - name: Set foreman OS variable
      set_fact:
        foreman_os: "RHEL 9.4"

    - name: Determine boot mode for each node
      set_fact:
        node_boot_modes: "{{ node_boot_modes | default([]) + [{'node': item, 'boot_mode': boot_mode_result}] }}"
      vars:
        boot_mode_result: >-
          {%- if item is match('.*(1029u|1029p|5039ms|6018r|6029p|6029r|6048p|6048r|6049p).*') -%}
            Bios
          {%- else -%}
            {%- set badfish_result = lookup('pipe', 'podman run quay.io/quads/badfish:latest --get-bios-attribute --attribute BootMode -H mgmt-' + item + ' -u ' + user + ' -p ' + password + ' -o json 2>&1 | jq -r .CurrentValue') -%}
            {%- if badfish_result and badfish_result != 'null' and badfish_result != '' -%}
              {{ badfish_result }}
            {%- else -%}
              UEFI
            {%- endif -%}
          {%- endif -%}
      loop: "{{ edpm_nodes }}"
      ignore_errors: true

    - name: Display boot mode detection results
      debug:
        msg: "Node {{ item.node }} will use boot mode: {{ item.boot_mode }}"
      loop: "{{ node_boot_modes }}"

    - name: Update Foreman host configuration for each node
      shell: |
        podman run \
          -v /tmp/foreman_config_updated_{{ cloud }}.yml:/opt/hammer/foreman_config.yml \
          quay.io/cloud-bulldozer/foreman-cli:latest \
          hammer \
          -c /opt/hammer/foreman_config.yml \
          --verify-ssl false \
          -u {{ cloud }} \
          -p {{ password }} \
          host update \
          --name {{ item.node }} \
          --operatingsystem "{{ foreman_os }}" \
          --pxe-loader "{{ 'PXELinux BIOS' if item.boot_mode == 'Bios' else 'PXELinux UEFI' }}" \
          --build 1
      loop: "{{ node_boot_modes }}"
      register: foreman_update_results
      ignore_errors: true

    - name: Display Foreman update results
      debug:
        msg: "Updated node {{ item.item.node }} with boot mode {{ item.item.boot_mode }}: {{ item.stdout_lines | default('No output') }}"
      loop: "{{ foreman_update_results.results }}"
      when: foreman_update_results.results is defined

    - name: Summary of Foreman host updates
      debug:
        msg: |
          Foreman host update summary:
          - Total nodes processed: {{ node_boot_modes | length }}
          - OS set to: {{ foreman_os }}
          - Nodes with BIOS boot: {{ node_boot_modes | selectattr('boot_mode', 'equalto', 'Bios') | list | length }}
          - Nodes with UEFI boot: {{ node_boot_modes | selectattr('boot_mode', 'equalto', 'UEFI') | list | length }}
          - Failed updates: {{ foreman_update_results.results | selectattr('failed', 'equalto', true) | list | length if foreman_update_results.results is defined else 0 }}

    - name: Set boot device for SuperMicro servers
      shell: |
        podman run quay.io/ocp-edge-qe/ipmitool ipmitool -I lanplus -H mgmt-{{ item.node }} -U {{ user }} -P {{ password }} chassis bootdev pxe
      loop: "{{ node_boot_modes | selectattr('boot_mode', 'equalto', 'Bios') | list }}"
      register: supermicro_bootdev_results
      ignore_errors: true

    - name: Set boot device for non-SuperMicro servers
      shell: |
        podman run quay.io/quads/badfish:latest -H mgmt-{{ item.node }} -u {{ user }} -p {{ password }} -i config/idrac_interfaces.yml -t foreman
      loop: "{{ node_boot_modes | rejectattr('boot_mode', 'equalto', 'Bios') | list }}"
      register: badfish_bootdev_results
      ignore_errors: true

    - name: Display boot device configuration results
      debug:
        msg: "Boot device configuration for {{ item.item.node }}: {{ 'SUCCESS' if not item.failed else 'FAILED' }}"
      loop: "{{ (supermicro_bootdev_results.results | default([])) + (badfish_bootdev_results.results | default([])) }}"
      when: supermicro_bootdev_results.results is defined or badfish_bootdev_results.results is defined

    - name: Reboot all nodes
      shell: |
        podman run quay.io/quads/badfish:latest --reboot-only -H mgmt-{{ item.node }} -u {{ user }} -p {{ password }}
      loop: "{{ node_boot_modes }}"
      register: reboot_results
      ignore_errors: true

    - name: Display reboot results
      debug:
        msg: "Reboot command for {{ item.item.node }}: {{ 'SUCCESS' if not item.failed else 'FAILED' }}"
      loop: "{{ reboot_results.results }}"
      when: reboot_results.results is defined

    - name: Wait for SSH connectivity on all nodes
      shell: |
        timeout=600
        delay=120
        elapsed=0
        while [ $elapsed -lt $timeout ]; do
          if sshpass -p "{{ ssh_password }}" ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@{{ item.node }} 'echo "SSH connection successful"' 2>/dev/null; then
            echo "SSH connection successful to {{ item.node }}"
            exit 0
          else
            echo "SSH not ready on {{ item.node }}, waiting... (elapsed: ${elapsed}s)"
            sleep $delay
            elapsed=$((elapsed + delay))
          fi
        done
        echo "SSH connection timeout to {{ item.node }}"
        exit 1
      loop: "{{ node_boot_modes }}"
      register: ssh_wait_results
      ignore_errors: true

    - name: Verify hostname on each node via SSH
      shell: |
        sshpass -p "{{ ssh_password }}" ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@{{ item.node }} 'hostname'
      loop: "{{ node_boot_modes }}"
      register: hostname_verification_results

    - name: Clean up old SSH keys for all nodes
      shell: |
        ssh-keygen -R {{ item.node }} 2>/dev/null || true
      loop: "{{ node_boot_modes }}"

    - name: Add new SSH keys to known_hosts
      shell: |
        ssh-keyscan {{ item.node }} >> ~/.ssh/known_hosts
      loop: "{{ node_boot_modes }}"

    - name: Display SSH connectivity results
      debug:
        msg: "SSH connectivity to {{ item.item.node }}: {{ 'SUCCESS' if not item.failed else 'FAILED' }}"
      loop: "{{ ssh_wait_results.results }}"
      when: ssh_wait_results.results is defined

    - name: Display hostname verification results
      debug:
        msg: "Hostname verification for {{ item.item.node }}: {{ 'SUCCESS - Hostname: ' + item.stdout if not item.failed else 'FAILED' }}"
      loop: "{{ hostname_verification_results.results }}"
      when: hostname_verification_results.results is defined